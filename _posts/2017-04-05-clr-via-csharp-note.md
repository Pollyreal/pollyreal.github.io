---
date: 2017-04-05 16:29:31+00:00
layout: post
title: CLR via C#学习笔记
categories: 文档
tags: 笔记 
---

[TOC]
# CLR via C#学习笔记
## C#类型和成员基础
### 访问性
成员访问性默认选择private。

接口类型的所有成员public可访问性。

C#派生类型重写基类型定义的一个成员时，C#编译器要求原始成员和重写成员具有相同的可访问性。
而CLR允许放宽成员的可访问限制，但不允许收紧。
CLR承诺派生类总是可以转型为基类。

### 静态类
static关键字只能应用于类，不能应用于结构（值类型）。因为CLR总是允许值类型实例化。

限制：
- 静态类必须直接从基类Sytem.Object派生
- 静态类不能实现任何接口，这是因为只有使用类的一个实例时，才可以调用类的接口方法。
- 静态类只能定义静态成员（字段、方法、属性和事件），任何实例成员都会导致报错。
- 静态类不能作为字段、方法参数或局部变量使用，因为它们都代表引用了一个实例的变量。

### 分部类、结构和接口
partial 关键字告诉C#编译器，一个类、结构或者接口的定义源代码可能要分散到一个或者多个源代码文件中。
- 源代码控制：类型的代码分散到多个源代码文件中，每个文件都可以单独签出，使多个程序员能同时编辑类型。
- 在同一个文件中，将一个类或结构分解成不同的逻辑单元。
- 代码拆分

CLR对分部类型一无所知。

### 组件、多态和版本控制
现在的应用程序一般都包含了由许多不同的公司生成的代码，通过面向对象编程机制契合到一起。

- 组件
    - 已经发布
    - 有自己的标识（名称、版本、语言、公钥）
    - 永远维持自己的标识（动态链接）
    - 引用元数据表
    - 文档化（xml、doc编译器）
    - 指定它要求的安全权限
    - 向后兼容，维护版本不能要求新的依赖关系和附加的安全权限。



设计一个类型时，应尽量减少所定义的虚方法的数量。如果希望方法是多态的，使最复杂的方法称为虚方法，使所有重载的简便方法成为非虚方法。

- 合理使用类型的可见性和成员的可访问性
    - 新类型应默认生成为密封类
        - 版本控制
        - 性能
        - 安全性和可预测性
        
## 常量和字段

### 常量
常量constant有一个从不变化的值，基元类型。

总是被视为类型定义的一部分，换言之，总是被视为静态成员，而不是实例成员。

运行时不给常量分配内存，不能获取常量地址，不能以传引用的方式传递常量。

常量没有很好的跨程序集版本控制特性。

如果希望在运行时从一个程序集中提取另一个程序集中的值，那么不应该使用常量，而应该使用readonly字段。

### 字段
- static
- （默认）
- readonly
- volatile：编译器、CLR或硬件就不会执行一些“线程不安全”的优化措施


readonly的字段可在构造器中修改。

## 方法
### 实例构造器和类（引用类型）
构造器是允许将类型的实例初始化Wie良好状态的一种特殊方法。
在调用类型的实例构造器之前，为对象分配的内存总是先被归零。

实例构造器永远不能被继承。

如果基类没有提供无参构造器，那么派生类必须显式调用一个基类构造器。如果类的修饰符为static（sealed和abstract），编译器不会再类的定义中生成一个默认构造器。

#### 使用this关键字来显示调用另一个构造器

``` csharp
using System;
internal sealed class SomeType
{
    private Int32 m_x;
    private String m_s;
    private Double m_d;
    private Byte m_b;
    
    public SomeType()
    {
        m_x = 5;
        m_s = "Hi there";
        m_d = 3.14159;
        m_b = 0xff;
    }
    
    //该构造器将所有的字段都设为默认值，然后修改m_x
    public SomeType(Int32 x):this()
    {
        m_x=x;
    }
}
```

### 实例构造器和结构（值类型）
CLR 总是允许创建值类型的实例，并且么有办法阻止值类型的实例化。

结构不能包含显式的无参数构造器。

### 类型构造器
类型构造器的作用是设置类型的初始状态。

类型构造器必须被标记为static，总是私有的。--阻止任何由开发人员写的代码调用它，对它的调用总是由CLR负责的。

在每个AppDomain中，一个类型构造器只执行一次，为此，在调用类型构造器时，调用线程要获取一个 ***互斥线程同步锁***。
如果多个线程试图同时调用某个类型的静态构造器，只有一个线程才可以获得锁，其他线程会被阻塞。

类型构造器不应调用基类型的类型构造器，没必要，因为类型不可能有静态字段从基类型分享或继承的。

### 转换操作符方法
如果源类型或目标类型不是基元类型，编译器会生成代码，要求CLR执行转换（强制转型）。

### 扩展方法
提高可维护性，对代码行为的理解
> 为了将IndexOf方法转变成扩展方法，只需在第一个参数前加this关键字

```csharp
pulic static class StringBuilderExtensions
{
    public static Int32 IndexOf(this StringBuilder sb,Char value)
    {
        for(Int32 index = 0; index < sb.Length; index++)
            if(sb[index] == value) return index;
        return -1;
    }
}
```
```csharp
Int32 index = sb.IndexOf('X');
```
“智能感知”功能

### 规则和原则
- C#只支持扩展方法，不支持扩展属性、扩展事件、扩展操作符等。
- 扩展方法必须在非繁星的静态类中声明，扩展方法至少要有一个参数，而且只有第一个参数能用this关键字标记。
- C#编译器查找静态类中定义的扩展方法时，要求这些静态类本身必须具有文件作用域。扩展方法必须在顶级静态类中定义。
- “导入”扩展方法：using SomeNamespace
- 多个静态类可以定义相同的扩展方法
- 谨慎，不是所有程序员熟悉它。可能造成VS的“智能感知”窗口被填充太多的辣鸡信息。
- 潜在版本控制问题。

### 用扩展方法扩展各种类型
- 扩展方法实际是对一个静态方法的调用，所以CLR不会对调用方法的表达式的值进行null值检查
- 可以为接口类型定义扩展方法
    ```csharp
    public static void ShowItems<T>(this IEnumerable<T> collection)
    {
        foreach(var item in collection)
        {
            Console.WriteLine(item);
        }
    }
    ```
    
    ***扩展方法是Microsoft的LINQ（Language Integrated Query，语言集成查询）技术的基础。***
- 可为委托类型定义扩展方法，或者为枚举类型添加扩展方法
- 允许创建一个委托，让它引用一个对象上的扩展方法
    ```csharp
    public static void Main()
    {
        Action a="Jeff".ShowItems;
        
        //调用（Invoke）委托，后者调用（call）ShowItems,
        //并向它传递对字符串“Jeff”的引用
        a();
    }
    ```
### 分部方法
定制类的行为

- 只能在分部类或结构中声明
- 返回类型始终是void，任何参数不能用out修饰符来标记
- 声明和实现必须具有完全一致的签名。
- 如果没有对应的实现部分，便不能在代码中创建一个委托来引用这个分部方法。
- 总是被视为private方法，禁止添加private关键字。