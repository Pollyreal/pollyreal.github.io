---
date: 2017-04-17 16:40:31+00:00
layout: post
title: CLR via C#学习笔记5-核心机制
categories: 文档
tags: 笔记
---
[TOC]
# CLR via C#学习笔记5
## 异常和状态管理
异常是指成员没有完成它的名称宣传可以完成的行动。
try...catch...finally
catch末尾，我们有一下三个选择：
- 重新抛出相同的异常，向调用栈高一层的代码通知该异常的发生。
- 抛出一个不同的异常，向调用栈高一层的代码提供更丰富的异常信息。
- 让线程从catch块的底部退出。
### CLR允许异常抛出任何类型的实例--从Int32到String都可以。
System.Exception是一个非常简单的类型，但是一般不要写任何代码以任何方式查询或访问这些属性。
### finally
许多编程语言都提供了一些构造来简化清理代码的编写。例如，只要使用了lock，using和foreach语句，C#编译器就会自动生成try/finally块。另外，重写一个类的析构器（Finalize方法）时，C#编译器也会自动生成try/finally块。
- 使用lock语句时，锁会在finally块中释放。
- 使用using语句时，会在finally块中调用对象的Dispose方法。
- 使用foreach语句时，会在finally块中调用IENumerator对象的Dispose方法。
- 定义析构器方法时，会在finally块中调用基类的Finalize方法。

## 自动内存管理（GC）
### 理解垃圾回收平台的基本工作原理
### 垃圾回收算法
### 使用终结操作来释放本地资源
### 对托管资源使用终结操作
### 什么会导致Finalize方法被调用
### 终结揭秘
### Dispose模式：强制对象清理资源
### 使用实现了Dispose模式的类型
### C#的using语句
### 一个有趣的依赖性问题
### 手动监视和控制对象的生存期
### 对象复活
### 代
### 用于本地资源的其他垃圾回收功能
### 预测需求大量内存的操作能否成功
### 编程控制垃圾回收器
### 线程劫持
### 垃圾回收模式
### 大对象
### 监视垃圾回收
## CLR寄宿和AppDomain
## 程序集加载和反射
## 运行时序列化
